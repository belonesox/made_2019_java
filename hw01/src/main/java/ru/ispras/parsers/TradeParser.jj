
options {
	CHOICE_AMBIGUITY_CHECK=3;
	OTHER_AMBIGUITY_CHECK=2;
	//DEBUG_PARSER=true
	//DEBUG_LOOKAHEAD=true
	//DEBUG_TOKEN_MANAGER=true
	ERROR_REPORTING=true;
	JAVA_UNICODE_ESCAPE=true;
	UNICODE_INPUT=true;
	IGNORE_CASE=true;
	SUPPORT_CLASS_VISIBILITY_PUBLIC=false;
	FORCE_LA_CHECK=true;
	CACHE_TOKENS=true;
  SANITY_CHECK = true;
	STATIC=false;
  //KEEP_LINE_COLUMN=true;
}

PARSER_BEGIN(TradeParser)

package ru.ispras.parser;

import java.io.*;
import java.util.*;
import java.math.*;
import ru.ispras.*;

/**
* Странный парсер для разбора информации о торговых сделках форекс для HW01 MADE 2019 Java курса.
* Все парсер-генераторы для явы ужасны, но попробую этот, вроде как наследник старого и распространненого 
* JavaCC и вроде как поддерживаемый.
* 
* Так как технически без странных кавычек (строго по ТЗ из https://data.mail.ru/blog/topic/view/14535/)
* не обойтись (т.е. стандартные парсеры JSON и конфигов не зайдут), а парсить регэкспами и руками — отстой, 
* будем делать свой парсер.
* 
* Парсер должен потреблять вход через {@code parse()}
* 
* Состояние не сбрасывается, и хрен с ним, трейдсейфности нет и не надо.
* 
* Set the {@code fallbackToString} property if you want to enable
* unparseable constructs (such as unqouted strings) to be handled as Strings: otherwise, they are a parse
* error.
*
*/

public class TradeParser {

	private boolean nativeNumbers = true;

	public TradeParser(String input) {
    this(new StringReader(input));
  }

	/**
	* Parses any JSON-parseable object, returning the value. 
	*/
	public Trade parse() throws ParseException { 
		Trade toReturn = object(); 
		if(!ensureEOF()) throw new IllegalStateException("Ожидается EOF, но разобран не до конца");
		return toReturn;
	}

	private static String substringBefore(String str, char delim) {
		int pos = str.indexOf(delim);
		if(pos == -1) return str;
		return str.substring(0, pos);
	}

	public void setNativeNumbers(boolean value) {
		this.nativeNumbers = value;
	}

	public boolean getNativeNumbers() {
		return this.nativeNumbers;
	}
}

PARSER_END(TradeParser)

// Вайтспейсы
SKIP: {
  <WHITESPACE: " " | "\t"> 
| <EOL: "\n" | "\r" | "\f"> 
}

// Запятые, может что-то еще.
TOKEN: {
	<COMMA: ",">
}

// Группировка
TOKEN:{
	<BRACE_OPEN: "{">
| <BRACE_CLOSE: "}">
| <COLON: ":">
}

// Числа (может конечно флоаты зря тащу, но пусть будут, стащил этот готовый кусок грамматики.)
TOKEN:{
	<#ZERO: "0">
| <#DIGIT_NONZERO: ["1"-"9"]>
| <#DIGIT: (<DIGIT_NONZERO> | <ZERO>) >
| <NUMBER_INTEGER:
		("-")?
		( (<ZERO>)+ | ( <DIGIT_NONZERO> (<DIGIT>)* ) ) 
	>
| <NUMBER_DECIMAL: 
		("-")?  
		( (<ZERO>)+ | ( <DIGIT_NONZERO> (<DIGIT>)* ) ) 
		("." 
			(<DIGIT>)+  
			(
				["e","E"]
				("+" | "-")?
				(<DIGIT>)+
			)?
		)
	>
}

// Разрешенные сделки
TOKEN :
{
    <FX_SPOT: "FX_SPOT">
    | <BOND: "BOND">
    | <COMMODITY_SPOT: "COMMODITY_SPOT">
    | <IR_SWAP: "IR_SWAP">
}

// Разрешенные ключи
TOKEN :
{
    <TYPE: "“type”">
    | <PRICE: "“price”">
}

// Префикс-ключ сделки
TOKEN :
{
    <PREFIX_TRADE: "Trade:">
}
 
boolean ensureEOF() : {}{
	<EOF>
	{ return true; }
}

Trade object() : {
	String type;
	Object value;
	Number price;
	Token t;
}{
    <PREFIX_TRADE>
	<BRACE_OPEN>
    <TYPE>
    <COLON>

    (
        (t = <FX_SPOT> {} )
    |   (t = <BOND> {} )
    |   (t = <COMMODITY_SPOT> {})
    |   (t = <IR_SWAP> {})
    )

    <COMMA>
    <PRICE>
    <COLON>
    price = objectPrice() 
	<BRACE_CLOSE>
	{ 
        switch(t.kind) {
            case FX_SPOT: return new FxSpot(price);   
            case BOND: return new Bond(price);   
            case COMMODITY_SPOT: return new CommoditySpot(price);   
            case IR_SWAP: return new IrSwap(price);   
        };
    }    
}


Number objectPrice() : {
	Number x;
}{
	( x = number()
	)
	{ return x; }
}

Number number(): {
	Token t;
}{ 
	(
		t = <NUMBER_DECIMAL>
		{ 
			if(nativeNumbers) {
				return new Double(t.image);
			} else {
				return new BigDecimal(t.image); 
			}
		}
	) | (
		t = <NUMBER_INTEGER>
		{ 
			if(nativeNumbers) {
				return new Integer(t.image);
			} else {
				return new BigInteger(substringBefore(t.image, '.')); 
			}
		}
	)
}


